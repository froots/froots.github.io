---
title: Full stack developer? Software engineer? Rockstar Ninja Hacker?
date: '2018-05-17 00:00:00'
---

When the World Wide Web started to take off as a commercial medium, it took a while for professional roles to form and settle. There were a lot of different titles flying around: _Webmaster_, _Web Developer_, _Web Designer_, even _Markup Author_. Some of these have stuck around, and others have died off.

Then as dynamic back-end technologies gained wide adoption, a natural split in specialisation occurred. Some developers stuck with mostly front end technologies, and some focused on server-side tech. But there were plenty of developers who tackled the whole stack. They weren't called _Full Stack Developers_, though. Just _Developers_ or _Web Developers_.

'Full Stack' as a modifier was added relatively recently. Look at this [Google Trends chart](https://trends.google.com/trends/explore?date=all&q=web%20developer,full%20stack%20developer,front%20end%20developer,software%20developer,software%20engineer) comparing various terms:

![Google Trends chart showing comparison between different developer titles](/images/list/20180517-trends.png)

Legend:

* Blue - _web developer_
* Purple - _software engineer_
* Green - _software developer_
* Yellow - _front end developer_
* Red - _full stack developer_

2012 or 2013 seems to be around the time the term started taking off in any meaningful way.

Local variations aside, I find this chart interesting for two reasons:

1. The limited use of _full stack developer_ goes against the chatter about it on social media.
2. The real story here is the rise of _software engineer_ over _web developer_.

Of course, software engineers don't just work on the web, but these data do seem to match something I've noticed in real life - that developers working on web applications are increasingly called _Software Engineers_ with no further modifier.

I have worked with companies whose hiring policy boils down to searching for capable or promising software engineers, and not worrying too much about current specialisation. The implication is that a good engineer is able to adapt and learn across languages, paradigms, architectural patterns, frameworks, syntax styles and runtime environment.

__Do you think this kind of generic hiring policy works in practice? What challenges does it present?__
